
#ifndef _LUA_ACCESS_CLASS_DEF__
#define _LUA_ACCESS_CLASS_DEF__

//incuded by lua_access.h
#include <cassert>

//class LuaStateHost
//{ 
//public:
//	LuaStateHost()
//		:_S(nullptr)
//	{
//
//	}
//
//private:
//	lua_State *_S;
//};

class FuncRef
{
public:
	FuncRef(lua_State *L)
		:_ref(LUA_REFNIL)
		,_refCounter(nullptr)
		,L_(L)
	{
	}

	FuncRef(const char *name, lua_State *L)
		:_ref(LUA_REFNIL)
		,_refCounter(nullptr)
		,L_(L)
	{
		loadFunc(name);
	}

	~FuncRef() 
	{
		deinit();
	}
	
	FuncRef(const FuncRef&rhs)
		:_ref(LUA_REFNIL)
		,_refCounter(nullptr)
		,L_(nullptr) {
		copy(rhs);
	}

	FuncRef& operator=(const FuncRef &rhs){
		return copy(rhs);
	}

	//FuncRef::FuncRef(const FuncRef&rhs)
	//	:_ref(LUA_REFNIL){
	//	_ref = ljDuplicateObj(rhs._ref);
	//}
	//
	//FuncRef& FuncRef::operator=(const FuncRef &rhs){
	//	ljReleaseObj(_ref);
	//	_ref = ljDuplicateObj(rhs._ref);
	//	return *this;
	//}

	void deinit()
	{
		if(_refCounter){
			--(*_refCounter);
			if(0 == *_refCounter){
				luaL_unref(L_, LUA_REGISTRYINDEX, _ref);
				delete _refCounter;
			}
		}
		//detached
		_ref = LUA_REFNIL;
		_refCounter = nullptr;
	}

	FuncRef& copy(const FuncRef &rhs)
	{
		deinit();
		if( rhs._refCounter){
			_ref = rhs._ref;
			_refCounter = rhs._refCounter;
			L_ = rhs.L_;	//~ pure pointer.
			++(*_refCounter);
		}
		return *this;
	}

	bool require(const char *path)
	{
		deinit();
		lua_State *L = L_;
		const int top = lua_gettop(L);
		int traceback = 0;
		lua_getglobal(L, _GTrackBack);
		if(lua_isfunction(L, -1)){
			traceback = -2;
		}
		luaL_loadfile(L, path);
		if( lua_pcall(L, 0, 1, traceback)){
			lua_pop(L, 2); // Pop the error message. The top is generated by the tracker. And pop the "traceback"
			assert(top==lua_gettop(L));
			fprintf(stderr, "Error loading from %s\n", path);
			return false;
		}
		if(!lua_isfunction(L, -1)){
			fprintf(stderr,"Expecting a function from %s\n", path);
			lua_pop(L, 2);
			assert(top == lua_gettop(L));
			return false;
		}
		take(luaL_ref(L, LUA_REGISTRYINDEX));
		lua_pop(L, 1);
		assert( top == lua_gettop(L));
		return true;
	}

private:
	void take(int ref)
	{
		assert(LUA_REFNIL == _ref);
		assert( ! _refCounter );
		assert( ref != LUA_REFNIL);
		_ref = ref;
		_refCounter = new int(1);
	}

public:
	void loadFunc(const char *name)
	{
		assert( LUA_REFNIL == _ref );
		take(ljLoadFuncHandle(L_, name));
	}

	int createObj()
	{
		assert( LUA_REFNIL != _ref);
		return ljCreateTableFromFuncRef(L_, _ref, 1, [](lua_State *L, int n)->int{return lua_istable(L,n);});
	}

private:
	int _ref;
	int *_refCounter;
	lua_State *L_;
};

class ObjContainer{
public:
	ObjContainer(lua_State *L);
	~ObjContainer();
	bool addObject(int obj);
	int tableRef();
	void clear();

private:
	int _ref;
	int _objCount;
	lua_State *L_;

private:
	ObjContainer(const ObjContainer&);
	ObjContainer&operator=(const ObjContainer&);
};


#endif